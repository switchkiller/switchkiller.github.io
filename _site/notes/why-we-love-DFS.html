<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Why we love dfs</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@varunnurab" /><meta name="twitter:title" content="Why we love dfs" /><meta name="twitter:description" content="DFS - Depth First Search"><meta name="description" content="DFS - Depth First Search"><meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o"><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/why-we-love-DFS"><link rel="alternate" type="application/atom+xml" title="Barun." href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="http://www.gravatar.com/avatar/6f91bf41cec90b8d64bffc5853f26b12.png?s=80" class="gravatar"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Why we love dfs</h1><time>August 11, 2015</time></div><div class="divider"></div><h1 id="dfs---depth-first-search">DFS - Depth First Search</h1><p>Everyone loves graph theory. Because of its sweet simplicity and sour complexity.</p><p>Today I would love to share my thoughts on DFS.</p><h4 id="its-more-like-recursive-backtracking-but-clever">* Its more like recursive backtracking but clever!</h4><p>I would not discuss the complete algorithm the boring way. I will go our code way, ahah :)</p><h5 id="note-dfs-is-used-for-connected-components">Note: DFS is used for connected components.</h5><h3 id="but-what-makes-dfs-different-then-the-recursive-backtracking">But what makes DFS different then the recursive backtracking???</h3><p>The answer is, there we mark some nodes visited and some not visited.</p><p>It might sound like, how, whhaat, errr. But wait…. I am explaining</p><p>Actually, dfs is very simple method of traversal.</p><p>What we do is, we mark a <code>int dfs_num[V]</code> which will contain the information if the node has been visited or not.</p><p>BUT HOW??</p><ul><li><p>You will take a arbitary node, or vertex from the user. This is the starter node (vertex). Its from where the traversal will actually begin!</p></li><li><p>This vertex, (starter vertex) will be marked visited.</p></li><li><p>The vertex adjacent to it are checked, The idea is to take all the adjacent vertex into the stack, the one at the top of the stack is process, marked as visited and so on. We will get it through my code soon.</p></li><li><p>Again recursively, the vertex adjacent to the nearby vertex is taken into stack-frame.</p><pre><code>void dfs(int u){  //You took an element u to begin the traversal
  dfs_num[u] = DFS_BLACK; //We mark the visited node BLACK.
  TRvii (AdjList[u], v) //v is an iterator pointing to ii, where as AdjList is of a vector.
    if (dfs_num[v-&gt;first] == DFS_WHITE) //Self-explanatory
      dfs(v-&gt;first);
} //where v-&gt;first is the neighbor of vertex and v-&gt;second is the weight of the edge.
</code></pre></li></ul><p>Using STL for solving graphs is very convenient method.</p><p>###Finding the connected components.</p><p>Dfs is not only useful for traversal. Its much more.</p><p>Lets take a code to go through.</p><pre><code>    //inside func()
    numComponent = 0;
    REP(i,0,V-1){
      if (dfs_num[i] == DFS_WHITE)
        printf("Connected component %d :",++numComponent)
        dfs(i);
    }
</code></pre><hr /><p>##Finding the Articulation Point and Bridges:</p><p>Let me tell you, this problem is one of most interesting to me. You are given a road map which is undirected. It has many intersections as vertices and edges. Now you have create a sabotage. Yea,.. SABOTAGE, that has the minimum cost such that the road network breaks down. This problem is about finding the least cost articulation point (intersection) or the least cost bridge (road) in an undirected graph. (road-map.)</p><p>An articulation point is defined as a vertex in a graph G whose removal disconnects G. A graph without such point is called ‘biconnected’.</p><p>Suppose, you are a vandal seeking to disrupt the telephone network. Which station in should you choose to blow up to cause the maximum amount of damage? Observe that there is a single point of failure, a single vertex whose deletion disconnects a connected componenets of the graph. Such a vertex is called articulation vertex or cut node.Deleting it causes a loss of connectivity between other nodes.</p></article><div class="back"> <a href="/">Back</a></div></main></body></html>